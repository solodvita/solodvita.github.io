[] - обозначение массива
Ctrl+ D (обозначается также ^D) - ввод закончен.
** - возведение в степень
https://github.com/rbenv/rbenv

Переменные, которые начинаются со знака @, называются переменные экземпляра, они автоматически доступны в представлении; в данном случае, представление index.html.erb перебирает список @users и выводит строку HTML для каждого

gem update --system

rails new toy_app --css bootstrap -j webpack --skip-hotwire


./bin/dev

http://localhost:3000/rails/info/routes

yarn plugin import interactive-tools

yarn upgrade-interactive Обновляет зависимости в package.json, если yarn версии 2 или 3. Если yarn версии 1 используем yarn upgrade.

Классы — это всего лишь удобный способ организации функций (также называемых методами)


Несмотря на то, что touch предназначена для установки времени последнего изменения файлов или каталогов без каких-либо других воздействий, в качестве побочного эффекта эта команда создаёт новый (пустой) файл, если он не существует.

Техника включает в себя использование embedded (встроенного) Ruby в представлениях. 

(Разница между этими двумя типами встроенного Ruby заключается в том, что <% ... %> исполняет код внутри, в то время как <%= ... %> исполняет его и вставляет результат в шаблон.)

Тем не менее, такая ситуация не может длиться вечно

Ruby-комментарии начинаются со знака решетки # (также называемого “знак хэша” или (более поэтично) “октоторп”) и распространяются до конца строки.
$ rails console
>> 17 + 42   # Сложение целых чисел
=> 59
>> '#{foo} bar'     # Строки в одинарных кавычках не позволяют делать интерполяцию
=> "\#{foo} bar"

>> 'Новые строки (\n) и табуляция (\t) используют символ бэкслэш \.'
=> "Новые строки (\\n) и табуляция (\\t) используют символ бэкслэш \\."

>> a = [42, 8, 17]
=> [42, 8, 17]
>> a[0]               # В Ruby используются квадратные скобки для доступа к массиву.

=> 42
>> a[1]
=> 8
>> a[2]
=> 17
>> a[-1]              # Индексы могут быть даже отрицательными!
=> 17

Мы видим здесь, что в Ruby используются квадратные скобки для доступа к элементам массива.

Чтобы изменить массив, используются соответствующие “бэнг” методы (названы так, потому что восклицательный знак обычно произносится как “бэнг” в этом случае):

>> a
=> [42, 8, 17]
>> a.sort!
=> [8, 17, 42]
>> a
=> [8, 17, 42]

>> a
=> [42, 8, 17, 7, "foo", "bar"]
>> a.join                       # Объединение без ничего.
=> "428177foobar"
>> a.join(', ')                 # Объединение через запятую.
=> "42, 8, 17, 7, foo, bar"

header (заголовок) 

CSS-комментариев, т.e., поместив его внутрь /* … */

<%= render 'layouts/shim' %>
Эта строка приводит к поиску файла app/views/layouts/_shim.html.erb, обработке его содержимого и вставке результата в представление.
подчеркивание — универсальное соглашение для именования частичных шаблонов, которое позволяет идентифицировать все партиалы в каталоге с первого взгляда.

Правильная команда для установки Sass в Rails должна выглядеть так: ./bin/rails css:install:sass (без пробела после двоеточия). 

Sass был добавлен в проект с помощью Yarn (менеджер пакетов для JavaScript), после чего был создан файл стилей Sass (application.sass.scss) в директории app/assets/stylesheets. Команда также добавила скрипт build:css в ваш package.json файл, который использует Sass для компиляции CSS.

Строчка @import 'bootstrap/scss/bootstrap'; в файле стилей Sass или SCSS означает, что в ваш файл стилей будет импортировано содержимое файла bootstrap.scss из пакета Bootstrap, который предполагается находиться в директории node_modules/bootstrap/scss/.

Когда вы используете @import в Sass или SCSS:

Вы сообщаете компилятору, что хотите включить содержимое указанного файла в место, где находится @import.
Это позволяет использовать все миксины, переменные и стили из Bootstrap в вашем собственном файле стилей.
Это упрощает обновление Bootstrap, поскольку вам не нужно копировать и вставлять код Bootstrap в ваш файл; вместо этого вы просто ссылаетесь на исходный файл из пакета.

Это популярный способ использовать Bootstrap в проектах, так как позволяет легко переопределить переменные и стили Bootstrap, а также использовать его компоненты в своем CSS.

yarn build:css

Он сбросил мне отличную книгу Ruby Notes for Professionals, а после нее предложил мне поделать задачки на Codewars (настоятельно рекомендую, очень полезно для обучения).

данный момент не готов рассмотреть их предложение


CI/CD — это комбинация непрерывной интеграции (continuous integration) и непрерывного развертывания (continuous delivery) программного обеспечения в процессе разработки. 

https://habr.com/ru/articles/501510/

Благодаря этим удобствам и своей простоте фреймворк Stimulus позволяет быстро и грамотно структурировать даже большой frontend.

https://habr.com/ru/articles/112966/   Переписываем проект с Zend Framework на Rails

https://habr.com/ru/articles/590381/  Фронтенд на рельсах (почти) без JS

https://habr.com/ru/articles/570522/

Этот новый подход появляется в виде расширений, библиотек или альтернативных конфигураций в различных языках и web фреймворках: Sockpuppet(Django), Phoenix LiveView(Elixir), Korolev(Scala), ts-liveview(NodeJS), Hotwire(Ruby), Vaadin(Java). Поищите библиотеки на основе WebSocket для вашего любимого фреймворка и попробуйте использовать новый способ проектирования архитектуры вашего приложения. Постройте что-нибудь удивительное и восхищайтесь великолепными кусочками HTML, проносящимися по сокетам подобно реактивному истребителю по ночному небу. Это больше, чем новый технический подход, это новый способ мышления и, возможно, даже источник новых фич, которые принесут вашему стартапу успех.

https://www.youtube.com/watch?v=TFymV80ZuAo

Если у вас маленькая и ограниченная ресурсами команда, Ruby on Rails служит мощным инструментом, позволяющий вам прыгнуть выше своей головы. С новым подходом ваша команда может создать на порядок больше функционала. Пока ваши конкуренты возятся с сериализацией JSON в своем API и борются за уменьшение количества индикаторов загрузки в своем UI, вы запускаете новую многопользовательскую функцию для совместной работы каждую неделю или даже день.

И все в выигрыше: разработчики, бизнес и, что самое главное, ваши пользователи.

Сама миграция представляет собой метод change, определяющий изменения, которые необходимо внести в базу данных. 

Название таблицы во множественном числе (users), даже при том, что название модели в единственном (User), отражает лингвистическое соглашение, которому следует Rails: модель представляет единственного (отдельного) пользователя, тогда как таблица базы данных состоит из многих пользователей.

В данном случае, хэшированный пароль и дайджест-пароль являются синонимами.)

rails routes

bin/rails db:create
bin/rails db:migrate

 повторное отображение шаблона через render не считается запросом. В результате флэш-сообщение существует на один запрос дольше, чем мы хотим. Например, если мы отправим невалидную информацию для входа, а затем перейдем на Home-страницу, флэ-сообщение отобразится во второй раз

 Мы можем работать с session, как с хэшем, и присваивать ему значения вот так:

session[:user_id] = user.id

В отличие от постоянных куки, создаваемых методом cookies, временные уничтожаются сразу после закрытия браузера.

временные куки, создаваемые методом session, автоматически шифруются
Это относится только к временным сессиям, запущенным методом session, но не относится к постоянным, запущенным методом cookies. Постоянные куки уязвимы для атак типа session hijacking

### Переменная экземпляра
Что такое переменная экземпляра в руби?
Переменная экземпляра в Ruby — это переменная, которая принадлежит конкретному объекту (экземпляру класса). Она определяется с префиксом @ и может использоваться в любом месте класса, позволяя различным методам класса делиться состоянием объекта. Каждый экземпляр класса имеет свой набор значений для своих переменных экземпляра, что делает состояние каждого объекта уникальным.

Вот пример использования переменной экземпляра в классе Ruby:

ruby

class Person
  def initialize(name)
    @name = name  # @name является переменной экземпляра
  end

  def greet
    "Hello, #{@name}!"  # Здесь используется переменная экземпляра
  end
end

person = Person.new("Alice")
puts person.greet  # Выведет "Hello, Alice!"

В этом примере @name — это переменная экземпляра, уникальная для каждого объекта Person.

---
или оператор ||

оператор ||= (“или равно”) 

всё, кроме nil и false, является true в логическом значении,

с помощью восклицательного знака ! и обычно читаемого “bang”

"Buffer" это онлайн-инструмент для управления социальными сетями, который позволяет пользователям планировать публикации, отслеживать эффективность своего контента и управлять всеми своими учетными записями в соцсетях из одного интерфейса. Если вам нужно больше информации о сайте Buffer или как он работает, я могу помочь с этим.

 Валидации это правила, проверяемые до сохранения объекта модели.

 В языке программирования Ruby символ (symbol) — это легковесный идентификатор, который используется вместо строк. Символы начинаются с двоеточия (:), за которым следует имя символа. Например, :user_name или :id.

Символы особенно полезны, когда вам нужно представить некоторые имена, метки, ключи в хэшах и другие опции, которые не изменяются в течение времени выполнения программы. Они являются неизменяемыми, что означает, что два символа с одинаковым именем ссылаются на один и тот же объект в памяти, в отличие от строк, где каждая одинаковая строка — это отдельный объект.

```options = { :font_size => 10, :font_family => "Arial" }```

В современном Ruby часто используется новый синтаксис для хэшей, где если ключ — символ, то можно использовать key: value вместо :key => value:

```options = { font_size: 10, font_family: "Arial" }```

валидации — это методы, вызванные на уровне класса.
